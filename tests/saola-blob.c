/*
  Produced code for (tf^1)+((tf+1)+((tf+1)+((tf+1)+((tf+1)+(tf+((tf+1)+(tf+1)*long_peek(variables))))))):

  [+   0] subq $0x28, %rsp
  [+   4] mov %rbx, (%rsp)
  [+   8] mov %rbp, 0x8(%rsp)
  [+  13] mov %r12, 0x10(%rsp)
  [+  18] mov 0x8(%rdi), %rcx
  [+  22] xorq $0x1, %rcx
  [+  26] mov 0x8(%rdi), %r8
  [+  30] incq %r8
  [+  33] mov 0x8(%rdi), %r9
  [+  37] incq %r9
  [+  40] mov 0x8(%rdi), %r10
  [+  44] incq %r10
  [+  47] mov 0x8(%rdi), %r11
  [+  51] incq %r11
  [+  54] mov 0x8(%rdi), %rbx
  [+  58] incq %rbx
  [+  61] mov 0x8(%rdi), %rbp
  [+  65] incq %rbp
  [+  68] mov 0x70(%rdi), %r12
  [+  72] mov (%r12), %r12
  [+  76] imul %r12, %rbp
  [+  80] add %rbp, %rbx
  [+  83] add 0x8(%rdi), %rbx
  [+  87] add %rbx, %r11
  [+  90] add %r11, %r10
  [+  93] add %r10, %r9
  [+  96] add %r9, %r8
  [+  99] add %r8, %rcx
  [+ 102] mov %rcx, %rax
  [+ 105] mov (%rsp), %rbx
  [+ 109] mov 0x8(%rsp), %rbp
  [+ 114] mov 0x10(%rsp), %r12
  [+ 119] addq $0x28, %rsp
  [+ 123] ret 
  [+ 124] .byte 0x00, 0x00, 0x00, 0x00

*/

typedef double (*RpnFun_t)(void *);

/* Evaluation function. */
double eval(const double *const variables,
            const RpnFun_t *const functions,
            void *arg) {
asm (
	".byte 0x48, 0x83, 0xec, 0x28, 0x48, 0x89, 0x1c, 0x24, 0x48, 0x89, 0x6c, 0x24, 0x08, 0x4c, 0x89, 0x64, 0x24, 0x10, 0x48, 0x8b, 0x4f, 0x08, 0x48, 0x83, 0xf1, 0x01, 0x4c, 0x8b, 0x47, 0x08, 0x49, 0xff, 0xc0, 0x4c, 0x8b, 0x4f, 0x08, 0x49, 0xff, 0xc1, 0x4c, 0x8b, 0x57, 0x08, 0x49, 0xff, 0xc2, 0x4c, 0x8b, 0x5f, 0x08, 0x49, 0xff, 0xc3, 0x48, 0x8b, 0x5f, 0x08, 0x48, 0xff, 0xc3, 0x48, 0x8b, 0x6f, 0x08, 0x48, 0xff, 0xc5, 0x4c, 0x8b, 0x67, 0x70, 0x4d, 0x8b, 0x24, 0x24, 0x49, 0x0f, 0xaf, 0xec, 0x48, 0x01, 0xeb, 0x48, 0x03, 0x5f, 0x08, 0x49, 0x01, 0xdb, 0x4d, 0x01, 0xda, 0x4d, 0x01, 0xd1, 0x4d, 0x01, 0xc8, 0x4c, 0x01, 0xc1, 0x48, 0x89, 0xc8, 0x48, 0x8b, 0x1c, 0x24, 0x48, 0x8b, 0x6c, 0x24, 0x08, 0x4c, 0x8b, 0x64, 0x24, 0x10, 0x48, 0x83, 0xc4, 0x28, 0xc3, 0x00, 0x00, 0x00, 0x00\n"
);
}
